let Redis,player,ship,cargo,leaderboard;_117‍.x([["RedisManager",()=>RedisManager]]);_117‍.w("ioredis",[["default",["Redis"],function(v){Redis=v}]]);_117‍.w("../shared/player",[["player",["player"],function(v){player=v}]]);_117‍.w("../shared/ship",[["ship",["ship"],function(v){ship=v}]]);_117‍.w("../shared/cargo",[["cargo",["cargo"],function(v){cargo=v}]]);_117‍.w("../shared/leaderboard",[["leaderboard",["leaderboard"],function(v){leaderboard=v}]]);





       class RedisManager {
    constructor() {
        // In production, this will use ElastiCache configuration
        this.redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');
        this.pubsub = new Redis(process.env.REDIS_URL || 'redis://localhost:6379');
        
        // Subscribe to game events
        this.pubsub.subscribe('game:state:update');
        this.pubsub.on('message', this.handleMessage.bind(this));
    }

    async handleMessage(channel, message) {
        if (channel === 'game:state:update') {
            try {
                const update = JSON.parse(message);
                switch (update.type) {
                    case 'player:move':
                        await this.updatePlayerPosition(update.playerId, update.position);
                        break;
                    case 'ship:update':
                        await this.updateShipState(update.shipId, update.state);
                        break;
                    case 'game:sync':
                        await this.handleGameSync(update.state);
                        break;
                }
            } catch (err) {
                _117‍.g.console.error('Error handling Redis message:', err);
            }
        }
    }

    async handleGameSync(state) {
        try {
            // Convert objects to Redis-compatible format
            const playerPromises = Object.entries(state.players).map(([id, data]) => 
                this.redis.hset('players', id, JSON.stringify(data))
            );
            
            const shipPromises = Object.entries(state.ships).map(([id, data]) => 
                this.redis.hset('ships', id, JSON.stringify(data))
            );

            await Promise.all([
                ...playerPromises,
                ...shipPromises,
                this.redis.set('cargo', JSON.stringify(state.cargo)),
                this.redis.set('leaderboard', JSON.stringify(state.leaderboard))
            ]);
        } catch (err) {
            _117‍.g.console.error('Error syncing game state:', err);
        }
    }

    async getGameState() {
        try {
            const [players, ships, cargo, leaderboardData] = await Promise.all([
                this.redis.hgetall('players') || {},
                this.redis.hgetall('ships') || {},
                this.redis.get('cargo').then(data => JSON.parse(data || '[]')),
                this.redis.get('leaderboard').then(data => JSON.parse(data || '{}'))
            ]);

            return {
                players: Object.entries(players).reduce((acc, [id, data]) => {
                    try {
                        acc[id] = JSON.parse(data);
                    } catch (e) {
                        _117‍.g.console.error('Error parsing player data:', e);
                        acc[id] = {};
                    }
                    return acc;
                }, {}),
                ships: Object.entries(ships).reduce((acc, [id, data]) => {
                    try {
                        acc[id] = JSON.parse(data);
                    } catch (e) {
                        _117‍.g.console.error('Error parsing ship data:', e);
                        acc[id] = {};
                    }
                    return acc;
                }, {}),
                cargo,
                leaderboard: leaderboardData
            };
        } catch (err) {
            _117‍.g.console.error('Error getting game state:', err);
            return {
                players: {},
                ships: {},
                cargo: [],
                leaderboard: {}
            };
        }
    }

    async updateGameState(state) {
        try {
            // Publish the update to all instances
            await this.redis.publish('game:state:update', JSON.stringify({
                type: 'game:sync',
                state
            }));

            // Update the state in Redis
            await this.handleGameSync(state);
        } catch (err) {
            _117‍.g.console.error('Error updating game state:', err);
        }
    }

    async addPlayer(playerId, playerData) {
        try {
            // Ensure we're only storing serializable data
            const serializableData = {
                username: playerData.username,
                position: playerData.position,
                health: playerData.health,
                currentShip: playerData.currentShip,
                playerView: playerData.playerView,
                pair: playerData.pair,
                keys: playerData.keys || {}
            };
            
            await this.redis.hset('players', playerId, JSON.stringify(serializableData));
            await this.redis.publish('game:state:update', JSON.stringify({
                type: 'player:join',
                playerId,
                playerData: serializableData
            }));
        } catch (err) {
            _117‍.g.console.error('Error adding player:', err);
            // Throw the error so we can handle it in the game class
            throw err;
        }
    }

    async removePlayer(playerId) {
        try {
            await this.redis.hdel('players', playerId);
            await this.redis.publish('game:state:update', JSON.stringify({
                type: 'player:leave',
                playerId
            }));
        } catch (err) {
            _117‍.g.console.error('Error removing player:', err);
        }
    }

    async updatePlayerPosition(playerId, position) {
        try {
            const playerData = await this.redis.hget('players', playerId);
            if (playerData) {
                const player = JSON.parse(playerData);
                player.position = position;
                await this.redis.hset('players', playerId, JSON.stringify(player));
                
                // Notify other instances about the position update
                await this.redis.publish('game:state:update', JSON.stringify({
                    type: 'player:move',
                    playerId,
                    position
                }));
            }
        } catch (err) {
            _117‍.g.console.error('Error updating player position:', err);
        }
    }

    async updateShipState(shipId, state) {
        await this.redis.hset('ships', shipId, JSON.stringify(state));
    }

    async updateLeaderboard(leaderboardData) {
        try {
            await this.redis.set('leaderboard', JSON.stringify(leaderboardData));
        } catch (err) {
            _117‍.g.console.error('Error updating leaderboard:', err);
        }
    }

    async cleanup() {
        try {
            await this.redis.quit();
            await this.pubsub.quit();
        } catch (err) {
            _117‍.g.console.error('Error cleaning up Redis connections:', err);
        }
    }

    async clearState() {
        try {
            // Clear all game-related keys
            await Promise.all([
                this.redis.del('players'),
                this.redis.del('ships'),
                this.redis.del('cargo'),
                this.redis.del('leaderboard')
            ]);
            console.log('Redis state cleared successfully');
        } catch (err) {
            _117‍.g.console.error('Error clearing Redis state:', err);
        }
    }
} 